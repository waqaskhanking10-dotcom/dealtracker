window.aui.amd_define("@amzn/flow-metrics-web-lib-latency",function(){"use strict";function p(e,t){return`${e}+${t}`}class N extends Error{constructor(t){super(t),this.name="MetricsRuleError"}}var E=(e=>(e.aboveTheFold="aboveTheFold",e.functional="functional",e.firstContentfulPaint="firstContentfulPaint",e))(E||{}),C=(e=>(e.EXISTS="EXISTS",e.MAX="MAX",e.MIN="MIN",e.SUM="SUM",e.UNKNOWN="UNKNOWN",e))(C||{});let M=!1;const S={log:()=>{},error:()=>{},warn:()=>{}},k={log:(e,...t)=>{console.log(`[FlowMetrics] ${e}`,...t)},error:(e,...t)=>{console.error(`[FlowMetrics] ${e}`,...t)},warn:(e,...t)=>{console.warn(`[FlowMetrics] ${e}`,...t)}},i={log:(e,...t)=>{M?k.log(e,...t):S.log(e,...t)},error:(e,...t)=>{M?k.error(e,...t):S.error(e,...t)},warn:(e,...t)=>{M?k.warn(e,...t):S.warn(e,...t)}},O=()=>{M=!0},A=()=>{M=!1},U={aboveTheFold:"af",functional:"fn",firstContentfulPaint:"fcp_ovr"};function D(e,t,a="ERROR",l){let c;t instanceof Error?c=t:c={message:t?String(t):""},c.message.length===0?c.message=e:c.message=`${e} - ${c.message}`;const f={logLevel:a,attribution:"FlowMetricsWebLib",message:""};typeof window<"u"&&window.ueLogError?window.ueLogError(c,f):i.error(`CSM ueLogError not found: ${c.message}`,f)}const y=(e,t,a)=>{D(e,t,"ERROR")},R=(e,t)=>{typeof window<"u"&&window.uet?window.uet(U[e],void 0,void 0,t):i.error("CSM uet not found!")},_=()=>{if(typeof window>"u"){i.error("window is not initialized");return}if(window.ue===void 0){i.error("CSM ue not found");return}if(window.ue.isl){if(window.uex===void 0){i.error("CSM uex not found");return}window.uex("at")}};var I=(e=>(e.NodeEventDataNotFound="M003",e.MetricsCalculatorError="M004",e.MetricInstructionParsingError="M005",e))(I||{});function j(e,t){const a=function(s){const f=p(s.id,s.event);return e.get(f)},l=function(s){const f=(()=>{switch(s.operator){case C.MAX:return Math.max;case C.MIN:return Math.min;case C.SUM:return(u,w)=>u+w;default:throw new N(`Calculation error: Unknown operator : ${s.operator}!`)}})();return s.metricRules.map(u=>{const{combination:w,nodeEvent:v}=u;if(w)return l(w);if(v)return a(v);throw new N(`Calculation error: Unknown rule type : ${Object.keys(u)}!`)}).reduce((u,w)=>f(u,w))};return Object.freeze({calculateMetrics:function(){const s={};try{t.forEach(f=>{const{metricName:u,metricRule:{combination:w,nodeEvent:v}}=f;let h=0;if(w)h=l(w);else if(v)h=a(v);else throw new N(`Calculation error: Unknown rule type : ${Object.keys(f.metricRule)}!`);s[u]=h})}catch(f){y(I.MetricsCalculatorError,f)}return s}})}function F(e){const t=e.split("=");return t.length>=2?t[t.length-1]:null}function P(e){return e.metricName.startsWith("onFlowCardCallback=")?F(e.metricName):null}function T(e,t){return j(e,t).calculateMetrics()}function z(e,t){const a=T(e,t),l=a[E.aboveTheFold],c=a[E.functional],s=a[E.firstContentfulPaint];l&&c?(R(E.aboveTheFold,l),R(E.functional,c)):i.error("sendExperienceRenderMetrics: missing aboveTheFold or functional timestamp!"),s?R(E.firstContentfulPaint,s):i.error("sendExperienceRenderMetrics: using the CSM default fcp!"),_()}function X(e,t){window.P&&window.P.when?window.P.when("A").execute(a=>{const l=a;if(l&&l.trigger){const c=`fm:flowCardCallback+${e}`,s={completionTimestamp:t};l.trigger(c,s),i.log(`Triggered flow card event: ${c}`,s)}else i.error("AUI A object or trigger method not available")}):window.P?window.P.when||i.error("P.when method not available"):i.error("P object not available")}function J(){const e=new Map,t=new Set,a=new Map,l=new Map,c=new Map,s=new Map,f=function(n,r,o){i.log("registerInstrumentationEvents",JSON.stringify({nodeId:n,payload:r,timestamp:o})),o=o||Date.now();for(const[m,d]of Object.entries(r)){const g=p(n,m);if(s.set(g,{lastTimestamp:o,count:d.length,instrumentationEvents:new Set}),d.length===0)i.log("No need to record instrumentation events.",g,o),v(g,o);else for(const b of d)l.set(b,g),w(b)}},u=function(n,r){i.log("recordInstrumentationEvent",JSON.stringify({instrumentationId:n,timestampOverride:r})),c.set(n,r||Date.now()),w(n)},w=function(n){const r=c.get(n),o=l.get(n);if(!r||!o)return;const m=s.get(o);if(!m){y(I.NodeEventDataNotFound);return}const{lastTimestamp:d,count:g,instrumentationEvents:b}=m,$=Math.max(d,r);b.add(n),s.set(o,{lastTimestamp:$,count:g,instrumentationEvents:b}),g===b.size&&(i.log("All instrumentation events recorded",o,$),v(o,$))},v=function(n,r){t.has(n)?a.set(n,r):i.error(`The ${n} is not registered!`);const o=n.split("+")[0],d=F(o)||"flow_experience",g=e.get(d);g&&g.pendingNodeEvents.has(n)&&(g.pendingNodeEvents.delete(n),g.pendingNodeEvents.size===0&&(i.log(`Instruction set nodeEvents for ${d} is complete!`),h(g)))},h=function(n){const r=n.instructions[0],o=r?P(r):null;if(o){i.log(`Processing flow card callback for ${o}`);const d=T(a,[r])[r.metricName];X(o,d),i.log(`Removing flow card instruction set for ${o} from tracking`),e.delete(o)}else i.log("Processing regular metrics for flow_experience"),z(a,n.instructions),i.log("Removing regular metrics instruction set from tracking"),e.delete("flow_experience")},x=function(n,r){if(n.nodeEvent){const o=p(n.nodeEvent.id,n.nodeEvent.event);r.add(o)}else n.combination&&n.combination.metricRules.forEach(o=>{x(o,r)})},q=function(n){i.log("updateMetricInstructions",JSON.stringify(n));const r=new Set;n.forEach(g=>{x(g.metricRule,r)});const o=n[0],d=(o?P(o):null)||"flow_experience";e.set(d,{instructions:n,pendingNodeEvents:r}),i.log(`Created instruction set with key: ${d}`),G(n)},B=function(n,r){t.add(p(n,r))},L=function(n){const{combination:r,nodeEvent:o}=n;if(r)r.metricRules.forEach(m=>{L(m)});else if(o)B(o.id,o.event);else throw new N(`Unknown rule type : ${Object.keys(n)}!`)},G=function(n){try{n.forEach(r=>{L(r.metricRule)})}catch(r){t.clear(),y(I.MetricInstructionParsingError,r)}};return Object.freeze({registerInstrumentationEvents:f,recordInstrumentationEvent:u,updateMetricInstructions:q,flowCardsCallback:function(n,r){i.log("flowCardsCallback",JSON.stringify({slotName:n}));try{if(!window.P){i.error("P object not available");return}window.P.when("A").execute(o=>{const m=o;if(!m){i.error("AUI A object not available");return}const d=`fm:flowCardCallback+${n}`;m.on(d,r),i.log(`Subscribed to flow card event: ${d}`)})}catch(o){i.error("flowCardsCallback: Failed to subscribe to AUI event",o);return}},reset:function(){l.clear(),s.clear(),a.clear(),t.clear(),e.clear()},get instrumentation2NodeEvent(){return l},get nodeEventsData(){return s},get nodeEvents(){return a},get registerNodeEvents(){return t}})}const K=J();function W(){var s,f;const e=window==null?void 0:window.fm;if(!e)return;const{flowCardsCallback:t,registerInstrumentationEvents:a,recordInstrumentationEvent:l,updateMetricInstructions:c}=K;e.flowCardsCallback=t,e.registerInstrumentationEvents=a,e.recordInstrumentationEvent=l,e.updateMetricInstructions=c,e.enableDebugLogging=O,e.disableDebugLogging=A,c(e.i),e._calls&&(e._calls.registerInstrumentationEvents.forEach(u=>a(...u)),e._calls.recordInstrumentationEvent.forEach(u=>l(...u)),(s=e._calls.flowCardsCallback)==null||s.forEach(u=>t(...u)),(f=e._calls.updateMetricInstructions)==null||f.forEach(u=>c(...u))),delete e._calls}W()});
